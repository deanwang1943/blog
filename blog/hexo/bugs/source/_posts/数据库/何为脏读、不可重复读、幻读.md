---
title: 何为脏读、不可重复读、幻读
date: 2018-09-25 08:36:03
tags: [数据库]
categories: [数据库]
---

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 http://ifeve.com/db_problem/

## 2.0 前言

事务的隔离性是指多个事务并发执行的时候相互之间不受到彼此的干扰的特性，隔离性是事务 ACID 特性中的 I，根据隔离程度从低到高分为 Read Uncommitted（读未提交），Read Committed（读已提交），Repeatable Read（可重复读），Serializable（串行化）四种隔离级别。在具体介绍事务隔离性前先介绍几个名词，以便说明数据库在并发操作时候可能存在的问题，以便展开来探讨这四种隔离级别对应存在哪些问题，哪些隔离级别解决了哪些问题。

## 2.1 何为脏读、不可重复读、幻读

*   `脏读`
    所谓脏读是指一个事务中访问到了另外一个事务未提交的数据，如下图：

![](https://upload-images.jianshu.io/upload_images/5879294-6424e361ec6ae52e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700) image.png

如上图开启两个会话来模拟两个线程同时去访问数据库表 table 中 id=1 的记录，假设两个会话开启前数据库中 table 表中 id=1 的记录行里面的列 age 值为 5。会话 1 和 2 一开始都开启了显示的事务（只有执行 commit 命令才会提交数据的修改），会话 2 首先更新了 table 中 id=1 的记录行的 age 列的值为 10（更新前值为 5），在会话 2 执行 commit 提交前，会话 1 通过 select 语句查询 id=1 的记录行中 age 列的值，这时候如果存在脏读，则会话 1 读取到的 age 的值是 10 而不是 5 了，虽然会话 2 的更新还没有提交。那么脏读存在什么问题那? 如果会话 2 最后提交了，那么会话 1 虽然在会话 2 还没提交就读取到了修改的值，但是也没什么影响；但是如果会话 1 读取到会话 2 没有提交的数据后，会话 2 执行了 rollback，也就是没有把修改刷新到数据库，但是会话 1 已经使用了修改的数据，这就出现了错误。

*   `不可重复读`
    所谓不可重复读是指在一个事务内根据同一个条件对行记录进行多次查询，但是搜出来的结果却不一致。发生不可重复读的原因是在多次搜索期间查询条件覆盖的数据被其他事务修改了，下面借助图表来解析下不可重复读。![](https://upload-images.jianshu.io/upload_images/5879294-a5aa7d5671f3b770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700) image.png

如上图假设数据库表 table 里面 id=1 的记录行中 age 列一开始值为 5，然后会话 1 和会话 2 分别开启了一个事务，会话 1 首先查询 id=1 的记录中 age 字段值为 5，然后会话 2 修改 id=1 的记录中 age 的值为 10 然后提交了事务，然后会话 1 再次搜出 id=1 的记录中 age 的值，如果出现了不可重复读，则这时候搜出来的 age 的值为 10 而不是 5。需要注意的是会话 1 两次查询是在同一个事务内进行的，期间事务并没有提交。不可重复读的存在显得不是那么不可容忍，毕竟读取的是已经提交了的数据。

*   `幻读`
    所谓幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务 A 内第一次查询时候有 n 条记录，但是第二次同等条件下查询却又 n+1 条记录，这就好像产生了幻觉，为啥两次结果不一样那。其实和不可重复读一样，发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据。不同在于不可重复读是同一个记录的数据内容被修改了，幻读是数据行记录变多了或者少了：![](https://upload-images.jianshu.io/upload_images/5879294-2d4b770f4afd4871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700) image.png

如上图假设表 table 里面一开始有一个 id=3 的记录，会话 1 首先开启了一个事务，然后查找 id>2 的记录，会发现结果只有一个记录，然后会话 2 开启事务插入了 id=5 的一个记录，然后提交。这时候会话 1 再次查找 id>2 的记录，如果存在幻读，则这时候会话 1 会看到两条记录。

注：脏读是指一个事务读取到了其他事务没有提交的数据，不可重复读是指一个事务内多次根据同一个查询条件查询出来的同一行记录的值不一样，幻读是指一个事务内多次根据同个条件查出来的记录行数不一样。为了解决事务并发带来的问题，才有了事务规范中的四个事务隔离级别，不同隔离级别对上面问题部分或者全部做了避免。

# 最后

更多 Spring 事务传播性与事务隔离性的咨询可以[单击我](http://gitbook.cn/gitchat/activity/5b339cc2b3d1de6cd5e3cecb)

想了解更多关于粘包半包问题[单击我](http://gitbook.cn/gitchat/activity/5b13e6a675742e21d6d14ea4)
更多关于分布式系统中服务降级策略的知识可以单击 [单击我](http://gitbook.cn/gitchat/activity/5af1bbbb49aea92c952eb3cc)
想系统学 dubbo 的[单击我](http://gitbook.cn/gitchat/column/5adda21279e8c577efc8fbdf)
想学并发的童鞋可以 [单击我](http://gitbook.cn/gitchat/series/5af40af938c1ac1d8df9e125?isSeries=yes)
