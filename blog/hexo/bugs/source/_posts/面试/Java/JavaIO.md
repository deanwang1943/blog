### NIO模式

由于BIO存在的诸多问题，在jdk 1.4中，Java提供了一种非阻塞型的IO模型，也即NIO。NIO本质上采用的是IO多路复用模式，实际上就是一个事件驱动模型，简单的理解为一个服务器在绑定某个端口之后，其可以在一个线程了同时监听多个客户端连接，而且服务器可以对每个客户端分别设置对其哪些事件感兴趣。当客户端有对应的事件发生时，其就会通知服务器监听线程，服务器线程监听到对应的事件之后，其就会将其交由线程池处理对应的事件。实际上，Java的NIO模式在底层也是依赖于操作系统的多路复用模型，对于Linux系统，其底层是使用epoll模型实现的，而对于Mac os，其则是使用kqueue模型实现的。

这里的Selector就可以理解为一个多路复用器，每个客户端连接就是一个SocketChannel，这些SocketChannel会在Selector上注册，并且设置对各个Channel感兴趣的事件。当Selector监听到对应的事件之后，其就会将事件交由下层的线程处理。

这里NIO模式相对于BIO主要有以下几个优点：

* 因为是基于操作系统的多路复用模型，只需要监听客户端的各个事件即可，因而使用一个线程即可处理大量的客户端连接，非常适合高并发服务器的编排。并且这里如果客户端并发量非常大，那么是可以使用一个线程组来专门处理客户端channel的连接事件，然后将其余的读写事件向下分发到到相应的IO线程组里；
* 由于是基于事件驱动模型处理相应的IO事件，因而这里对客户端的数据处理是非常高效的。

### AIO模式

AIO本质上还是使用的NIO的多路复用来实现的，只不过在模型上其使用的是一种事件回调的方式处理各个事件，这种方式更加符合NIO异步模型的概念，并且在编码难易程度上比NIO要小很多。

在AIO中，所有的操作都是异步执行的，而每个事件都是通过一个回调函数来进行的

可以看到AIO模式相较于NIO有如下优点：

* 本质上是使用的IO多路复用模式，因而天然支持高并发模型；
* 底层使用了异步IO的模型，因而无需用户使用线程池等工具来分离相关事件的处理，而NIO是需要用户手动创建线程池进行处理的；
* 在编码模式上更加符合事件处理这一模型，更加符合用户习惯，降低了用户编码的难度。

### Linux IO说明

https://segmentfault.com/a/1190000003063859
